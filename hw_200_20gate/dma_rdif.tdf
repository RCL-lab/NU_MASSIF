

--------------------------------------------------------------------------------------
-- Gidel Copyright © 1993-2015  
-- HDL dma_rdif is generated by Gidel  ProcWizard Application  version 9.5.0.0
-- dma_rdif is the bus interface for ****  device (IC) 1 ****
-- This file was generated for PROC configuration file  :"D:\Drive\Research_Backup\2017_08_07_20gates\gc_procv.pcaf".
-- This file may only be used for initialization and usage of Gidel PROC boards.
-- Using this file, or any other related files, for any other purpose, is prohibited .
-- No other licenses are provided herein.

-- Created  Sat Aug 12 20:18:15 2017

-------------------------------------------------------------------------------------


  SUBDESIGN   dma_rdif
     (
    --============================================
    --=          Local bus connections           =
    --============================================
    clk                        : INPUT;                    -- local bus clock
    clrn                       : INPUT;                    -- Global reset signal. Active low
    blast_o                    : OUTPUT;
    blast                      : INPUT = GND;
    ads                        : INPUT;
    lw_r_i                     : INPUT;
    lw_r                       : OUTPUT;
    wait_l                     : INPUT = VCC;
    bterm                      : OUTPUT;
    ready                      : OUTPUT;
    addr[31..0]                : OUTPUT;                   -- local bus address
    ad_i[255..0]               : INPUT;
    ad_o[255..0]               : OUTPUT;
    ad[255..0]                 : OUTPUT;
    mem_data[255..0]           : INPUT = GND;
    --============================================
    --=       feedback from user memories        =
    --============================================
    mem_ready                  : INPUT;                    -- assert this signal high when memory data is valid
    term                       : INPUT = VCC;              -- assert this signal high to enable burst mode
    --============================================
    --=  Output from the logic to the host (status registers)  =
    --============================================
    comp_done                  : INPUT;
    -- version of RBF
    rbf_version[7..0]          : INPUT;                    -- RBF_Info[7..0]
    almost_full_wr             : INPUT;                    -- status_wr[1]
    empty_wr                   : INPUT;                    -- status_wr[2]
    almost_empty_rd            : INPUT;                    -- status_rd[0]
    almost_full_rd             : INPUT;                    -- status_rd[1]
    empty_rd                   : INPUT;                    -- status_rd[2]
    --============================================
    --=  Input from the host to the logic (mode registers)  =
    --============================================
    id2                        : INPUT = GND;
    id1                        : INPUT = GND;
    id0                        : INPUT = VCC;
    --============================================
    --=  Selectors to all memory address spaces  =
    --============================================
    sel_mp_rd                  : OUTPUT;
    )


VARIABLE

   
  ad_oe                      : LCELL;
  ready_i                    : NODE;
  sel_gmode                  : SRFF;
  sel_ic, sel_read_ic        : SRFF;
  sel_ic_lcell               : LCELL;
  addr[31..0]                : DFFE;
  ad_out[255..0]             : DFF;
  sel_ports                  : NODE;
  sel_ports_d                : DFF;
  bus_end                    : NODE;
  --============================================
  --=        Address decoder selectors         =
  --============================================
  den                        : SRFF;
  sel_comp_done              : SRFF;
  sel_RBF_Info               : SRFF;
  sel_status_wr              : SRFF;
  sel_status_rd              : SRFF;
  sel_mp_rd_ff               : SRFF;


BEGIN

    
  DEFAULTS
    ad_out[]              = GND;
  END DEFAULTS;
   
  ad_out[].clk    = clk;
  sel_ports_d.clk = clk;
  lw_r        = lw_r_i;
  ad[]      = ad_i[];
  IF sel_ports THEN
    ad_o[]  = ad_out[];        -- mode registers read back data to local bus
  ELSE
    ad_o[]  = mem_data[];
  END IF;
  ad_oe         = sel_read_ic;
  IF sel_comp_done THEN
    ad_out[0]=comp_done;
  END IF;


  IF sel_RBF_Info THEN
      ad_out[7..0]=rbf_version[7..0];
  END IF;


  IF sel_status_wr THEN
      ad_out[1]=almost_full_wr;
      ad_out[2]=empty_wr;
  END IF;


  IF sel_status_rd THEN
      ad_out[0]=almost_empty_rd;
      ad_out[1]=almost_full_rd;
      ad_out[2]=empty_rd;
  END IF;


  bus_end  = wait_l & !ready_i & !den & (!blast # !term) # ads & den;
  sel_gmode.clk         = clk;
  sel_gmode.clrn        = clrn;
  sel_gmode.r           = bus_end;
  ready                 = ready_i;
  bterm                 = VCC;
  sel_ic_lcell          = sel_ic;
  sel_ports             = sel_gmode;
  den.clk               = clk;
  den.s                 = bus_end;
  den.r                 = !ads;
  sel_ic.clk            = clk;
  sel_ic.clrn           = clrn;
  sel_ic.r              = bus_end;
  sel_read_ic.clk       = clk;
  sel_read_ic.clrn      = clrn;
  sel_read_ic.r         = bus_end;
  sel_comp_done.clk     = clk;
  sel_comp_done.clrn    = clrn;
  sel_comp_done.r       = bus_end;
    
  sel_RBF_Info.clk      = clk;
  sel_RBF_Info.clrn     = clrn;
  sel_RBF_Info.r        = bus_end;
    
  sel_status_wr.clk     = clk;
  sel_status_wr.clrn    = clrn;
  sel_status_wr.r       = bus_end;
    
  sel_status_rd.clk     = clk;
  sel_status_rd.clrn    = clrn;
  sel_status_rd.r       = bus_end;
    
  sel_mp_rd             = sel_mp_rd_ff & wait_l;
  sel_mp_rd_ff.clk      = clk;
  sel_mp_rd_ff.clrn     = clrn;
  sel_mp_rd_ff.r        = bus_end;
    
  IF !ads THEN
    addr[]                = ad[31..0];
  ELSE
    addr[]                = addr[] + 32;
  END IF;
  addr[].clk            = clk;
  addr[].ena            = !ads  #  wait_l & !ready_i & !den;
  --============================================
  --=  Selectors to all memory address spaces  =
  --============================================
    
    
  sel_ports_d = sel_ports;
   
  ready_i               = !sel_ic_lcell # !sel_ports_d & sel_read_ic & sel_ports # sel_mp_rd_ff & !mem_ready;
    
   
  



  IF !ads & !ad[31] THEN
    IF (ad[24..24] == 0) THEN
      IF (ad[23..21] == (id2,id1,id0) ) THEN
        sel_ic.s = VCC;
        sel_read_ic.s = !lw_r;
  
        IF !ad[20] THEN
          sel_gmode.s=VCC;
          sel_comp_done.s =  (ad[10..4] == H"4");
          sel_RBF_Info.s =  (ad[10..4] == H"0");
          sel_status_wr.s =  (ad[10..4] == H"7");
          sel_status_rd.s =  (ad[10..4] == H"8");
  
        ELSE
            -- SRAM / internal memories address space
          sel_mp_rd_ff.s = VCC &!lw_r;
        END IF;

      END IF;
    END IF;
  END IF;
  END;
