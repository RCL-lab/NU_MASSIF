

--------------------------------------------------------------------------------------
-- Gidel Copyright © 1993-2015  
-- HDL dma_if is generated by Gidel  ProcWizard Application  version 9.5.0.0
-- dma_if is the bus interface for ****  device (IC) 1 ****
-- This file was generated for PROC configuration file  :"D:\Drive\Research_Backup\2017_08_02_and_xor_pipeline\gc_procv.pcaf".
-- This file may only be used for initialization and usage of Gidel PROC boards.
-- Using this file, or any other related files, for any other purpose, is prohibited .
-- No other licenses are provided herein.

-- Created  Wed Aug 02 23:42:49 2017

-------------------------------------------------------------------------------------


INCLUDE  "g_avalon2if.inc";
INCLUDE  "dma_wrif.inc";
INCLUDE  "dma_rdif.inc";



     CONSTANT GDREQ_WR_NUM          = 1;
     CONSTANT GDREQ_RD_NUM          = 1;
     CONSTANT CONSUMER_COUNT        = 32;


  SUBDESIGN   dma_if
     (
    --============================================
    --=             Fixed connection             =
    --============================================
    ref_clk                    : INPUT;                    -- ref_clk
    clk0                       : OUTPUT;                   -- clk0
    clk                        : OUTPUT;                   -- clk
    clk2                       : OUTPUT;                   -- clk2
    mem_ref_clk_int            : OUTPUT;                   -- mem_ref_clk_int
    scl                        : BIDIR;                    -- scl
    sda                        : BIDIR;                    -- sda
    status_ledn[3..1]          : OUTPUT;                   -- status_ledn
    g_reserved[33..0]          : BIDIR;                    -- g_reserved
    clrn                       : OUTPUT;                   -- Reset input (active LOW)
    lclk                       : OUTPUT;                   -- Local clock
    user_dreq[31..0]           : INPUT;
    g_dreq_wr[GDREQ_WR_NUM-1..0]   : INPUT = GND;
    g_dreq_rd[GDREQ_RD_NUM-1..0]   : INPUT = GND;
    interrupt                  : INPUT;
    interrupt_ack              : OUTPUT;
    --============================================
    --=              Receiver I/O's              =
    --============================================
    g_reserved_control[99..0]   : OUTPUT;                  --  
    id[2..0]                   : OUTPUT;                   --  
    pcie_refclk                : INPUT;                    -- pcie_refclk
    pcie_perst                 : INPUT;                    -- pcie_perst
    pcie_rx[7..0]              : INPUT;                    -- pcie_rx
    pcie_tx[7..0]              : OUTPUT;                   -- pcie_tx
    --============================================
    --=               WR IF I/O's                =
    --============================================
    l_wr                       : OUTPUT;
    addr_wr[31..0]             : OUTPUT;
    addr_rd[31..0]             : OUTPUT;
    l_data_wr[255..0]          : OUTPUT;
    l_data_rd[255..0]          : INPUT = GND;
    l_rd                       : OUTPUT;
    mem_ready_wr               : INPUT = VCC;
    --============================================
    --=               RD IF I/O's                =
    --============================================
    mem_ready_rd               : INPUT = VCC;
    --============================================
    --=  Output from the logic to the host (status registers)  =
    --============================================
    comp_done                  : INPUT;
    -- version of RBF
    rbf_version[7..0]          : INPUT;                    -- RBF_Info[7..0]
    almost_full_wr             : INPUT;                    -- status_wr[1]
    empty_wr                   : INPUT;                    -- status_wr[2]
    almost_empty_rd            : INPUT;                    -- status_rd[0]
    almost_full_rd             : INPUT;                    -- status_rd[1]
    empty_rd                   : INPUT;                    -- status_rd[2]
    --============================================
    --=  Input from the host to the logic (mode registers)  =
    --============================================
    addr_1v[14..0][31..0]      : OUTPUT;
    addr_2v[14..0][31..0]      : OUTPUT;
    addr_3v[14..0][31..0]      : OUTPUT;
    gc_and_en[14..0]           : OUTPUT;
    R[2..0][31..0]             : OUTPUT;
    and_gt_id[29..0][31..0]    : OUTPUT;
    layer_num[31..0]           : OUTPUT;
    addr_1v_xor[14..0][31..0]   : OUTPUT;
    addr_2v_xor[14..0][31..0]   : OUTPUT;
    addr_3v_xor[14..0][31..0]   : OUTPUT;
    gc_xor_en[14..0]           : OUTPUT;
    xor_gt_id[14..0][31..0]    : OUTPUT;
    --============================================
    --=  Selectors to all memory address spaces  =
    --============================================
    sel_mp_wr                  : OUTPUT;
    sel_start_mp_wr            : OUTPUT;
    sel_mp_rd                  : OUTPUT;
    sel_start_mp_rd            : OUTPUT;
    )


VARIABLE
   g_pcielb2if_cmp            : g_avalon2if WITH (CONSUMER_COUNT = CONSUMER_COUNT , USER_ITRP_NUM  = 1,
     GDREQ_WR_NUM = GDREQ_WR_NUM,GDREQ_RD_NUM = GDREQ_RD_NUM, LBUS_FREQUENCY  = 200);
   dma_ifw                    : dma_wrif;
   dma_ifr                    : dma_rdif;




BEGIN

  g_reserved_control[]  = g_pcielb2if_cmp.g_reserved_control[];
  dma_ifw.id0           = g_pcielb2if_cmp.id0;
  dma_ifr.id0           = g_pcielb2if_cmp.id0;
  id[0]                 = g_pcielb2if_cmp.id0;
  dma_ifw.id1           = g_pcielb2if_cmp.id1;
  dma_ifr.id1           = g_pcielb2if_cmp.id1;
  id[1]                 = g_pcielb2if_cmp.id1;
  dma_ifw.id2           = g_pcielb2if_cmp.id2;
  dma_ifr.id2           = g_pcielb2if_cmp.id2;
  id[2]                 = g_pcielb2if_cmp.id2;
  g_pcielb2if_cmp.ref_clk  = ref_clk;
  clk0                  = g_pcielb2if_cmp.clk0;
  clk                   = g_pcielb2if_cmp.clk;
  clk2                  = g_pcielb2if_cmp.clk2;
  mem_ref_clk_int       = g_pcielb2if_cmp.mem_ref_clk_int;
  clrn                  = g_pcielb2if_cmp.clrn;
  scl                   = g_pcielb2if_cmp.scl;
  sda                   = g_pcielb2if_cmp.sda;
  status_ledn[]         = g_pcielb2if_cmp.status_ledn[];
  g_reserved[]          = g_pcielb2if_cmp.g_reserved[];
  g_pcielb2if_cmp.pcie_refclk  = pcie_refclk;
  g_pcielb2if_cmp.pcie_perst  = pcie_perst;
  g_pcielb2if_cmp.pcie_rx[]  = pcie_rx[];
  pcie_tx[]             = g_pcielb2if_cmp.pcie_tx[];
  g_pcielb2if_cmp.g_dreq_wr[]  = (0,g_dreq_wr[]);
  g_pcielb2if_cmp.g_dreq_rd[]  = (0,g_dreq_rd[]);
  g_pcielb2if_cmp.user_dreq[CONSUMER_COUNT-1..0]  = user_dreq[CONSUMER_COUNT-1..0];
  g_pcielb2if_cmp.interrupt[]  = interrupt;
  interrupt_ack         = g_pcielb2if_cmp.interrupt_ack[0..0];
  g_pcielb2if_cmp.ready_w  = dma_ifw.ready;
  g_pcielb2if_cmp.ready_r  = dma_ifr.ready;
  g_pcielb2if_cmp.ad_i_r[]  = dma_ifr.ad_o[];
  dma_ifw.clk           = g_pcielb2if_cmp.clk_w;
  dma_ifw.clrn          = clrn;
  dma_ifw.ads           = g_pcielb2if_cmp.ads_w;
  dma_ifw.ad_i[]        = g_pcielb2if_cmp.ad_o_w[];
  dma_ifw.lw_r_i        = g_pcielb2if_cmp.lw_r_w;
  dma_ifw.blast         = g_pcielb2if_cmp.blast_w;
  dma_ifw.wait_l        = g_pcielb2if_cmp.wait_l_w;
  lclk                  = g_pcielb2if_cmp.clk_w;
  l_wr                  = dma_ifw.lw_r;
  addr_wr[]             = dma_ifw.addr[];
  l_data_wr[]           = dma_ifw.ad[];
  dma_ifw.mem_ready     = mem_ready_wr;
  dma_ifr.clk           = g_pcielb2if_cmp.clk_r;
  dma_ifr.clrn          = clrn;
  dma_ifr.ads           = g_pcielb2if_cmp.ads_r;
  dma_ifr.ad_i[]        = g_pcielb2if_cmp.ad_o_r[];
  dma_ifr.lw_r_i        = g_pcielb2if_cmp.lw_r_r;
  dma_ifr.blast         = g_pcielb2if_cmp.blast_r;
  dma_ifr.wait_l        = g_pcielb2if_cmp.wait_l_r;
  l_rd                  = dma_ifr.lw_r;
  addr_rd[]             = dma_ifr.addr[];
  dma_ifr.mem_data[]    = l_data_rd[];
  dma_ifr.mem_ready     = mem_ready_rd;
  --============================================
  --=           Variable connection            =
  --============================================
  dma_ifr.comp_done                    =  comp_done;
  dma_ifr.rbf_version[]                =  rbf_version[];
  dma_ifr.almost_full_wr               =  almost_full_wr;
  dma_ifr.empty_wr                     =  empty_wr;
  dma_ifr.almost_empty_rd              =  almost_empty_rd;
  dma_ifr.almost_full_rd               =  almost_full_rd;
  dma_ifr.empty_rd                     =  empty_rd;
  addr_1v[][]                          =  dma_ifw.addr_1v[][];
  addr_2v[][]                          =  dma_ifw.addr_2v[][];
  addr_3v[][]                          =  dma_ifw.addr_3v[][];
  gc_and_en[]                          =  dma_ifw.gc_and_en[];
  R[][]                                =  dma_ifw.R[][];
  and_gt_id[][]                        =  dma_ifw.and_gt_id[][];
  layer_num[]                          =  dma_ifw.layer_num[];
  addr_1v_xor[][]                      =  dma_ifw.addr_1v_xor[][];
  addr_2v_xor[][]                      =  dma_ifw.addr_2v_xor[][];
  addr_3v_xor[][]                      =  dma_ifw.addr_3v_xor[][];
  gc_xor_en[]                          =  dma_ifw.gc_xor_en[];
  xor_gt_id[][]                        =  dma_ifw.xor_gt_id[][];
  sel_mp_wr                            =  dma_ifw.sel_mp_wr;
  sel_start_mp_wr                      =  dma_ifw.sel_start_mp_wr;
  sel_mp_rd                            =  dma_ifr.sel_mp_rd;
  sel_start_mp_rd                      =  dma_ifw.sel_start_mp_rd;
  END;
