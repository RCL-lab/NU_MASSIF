

--------------------------------------------------------------------------------------
-- Gidel Copyright © 1993-2015  
-- HDL dma_wrif is generated by Gidel  ProcWizard Application  version 9.5.0.0
-- dma_wrif is the bus interface for ****  device (IC) 1 ****
-- This file was generated for PROC configuration file  :"D:\Drive\Research_Backup\2017_08_02_and_xor_pipeline\gc_procv.pcaf".
-- This file may only be used for initialization and usage of Gidel PROC boards.
-- Using this file, or any other related files, for any other purpose, is prohibited .
-- No other licenses are provided herein.

-- Created  Wed Aug 02 23:42:48 2017

-------------------------------------------------------------------------------------


  SUBDESIGN   dma_wrif
     (
    --============================================
    --=          Local bus connections           =
    --============================================
    clk                        : INPUT;                    -- local bus clock
    clrn                       : INPUT;                    -- Global reset signal. Active low
    blast_o                    : OUTPUT;
    blast                      : INPUT = GND;
    ads                        : INPUT;
    lw_r_i                     : INPUT;
    lw_r                       : OUTPUT;
    wait_l                     : INPUT = VCC;
    bterm                      : OUTPUT;
    ready                      : OUTPUT;
    addr[31..0]                : OUTPUT;                   -- local bus address
    ad_i[255..0]               : INPUT;
    ad_o[255..0]               : OUTPUT;
    ad[255..0]                 : OUTPUT;
    mem_data[255..0]           : INPUT = GND;
    --============================================
    --=       feedback from user memories        =
    --============================================
    mem_ready                  : INPUT;                    -- assert this signal high when memory data is valid
    term                       : INPUT = VCC;              -- assert this signal high to enable burst mode
    --============================================
    --=  Input from the host to the logic (mode registers)  =
    --============================================
    addr_1v[14..0][31..0]      : OUTPUT;
    addr_2v[14..0][31..0]      : OUTPUT;
    addr_3v[14..0][31..0]      : OUTPUT;
    gc_and_en[14..0]           : OUTPUT;
    R[2..0][31..0]             : OUTPUT;
    and_gt_id[29..0][31..0]    : OUTPUT;
    layer_num[31..0]           : OUTPUT;
    addr_1v_xor[14..0][31..0]   : OUTPUT;
    addr_2v_xor[14..0][31..0]   : OUTPUT;
    addr_3v_xor[14..0][31..0]   : OUTPUT;
    gc_xor_en[14..0]           : OUTPUT;
    xor_gt_id[14..0][31..0]    : OUTPUT;
    id2                        : INPUT = GND;
    id1                        : INPUT = GND;
    id0                        : INPUT = VCC;
    --============================================
    --=  Selectors to all memory address spaces  =
    --============================================
    sel_mp_wr                  : OUTPUT;
    sel_start_mp_wr            : OUTPUT;
    sel_start_mp_rd            : OUTPUT;
    )


VARIABLE

   
  ad_oe                      : LCELL;
  ready_i                    : NODE;
  sel_gmode                  : SRFF;
  sel_ic, sel_read_ic        : SRFF;
  sel_ic_lcell               : LCELL;
  addr[31..0]                : DFFE;
  ad_out[255..0]             : DFF;
  sel_ports                  : NODE;
  sel_ports_d                : DFF;
  bus_end                    : NODE;
  --============================================
  --=  Fields and registers for writing by user  =
  --============================================
  addr_1v[14..0][31..0]      : DFFE;
  addr_2v[14..0][31..0]      : DFFE;
  addr_3v[14..0][31..0]      : DFFE;
  gc_and_en[14..0]           : DFFE;
  R[2..0][31..0]             : DFFE;
  and_gt_id[29..0][31..0]    : DFFE;
  layer_num[31..0]           : DFFE;
  addr_1v_xor[14..0][31..0]   : DFFE;
  addr_2v_xor[14..0][31..0]   : DFFE;
  addr_3v_xor[14..0][31..0]   : DFFE;
  gc_xor_en[14..0]           : DFFE;
  xor_gt_id[14..0][31..0]    : DFFE;
  --============================================
  --=        Address decoder selectors         =
  --============================================
  den                        : SRFF;
  sel_addr_1v [14..0]        : SRFF;
  sel_addr_2v [14..0]        : SRFF;
  sel_addr_3v [14..0]        : SRFF;
  sel_gc_and_en              : SRFF;
  sel_R [2..0]               : SRFF;
  sel_and_gt_id [29..0]      : SRFF;
  sel_layer_num              : SRFF;
  sel_addr_1v_xor [14..0]    : SRFF;
  sel_addr_2v_xor [14..0]    : SRFF;
  sel_addr_3v_xor [14..0]    : SRFF;
  sel_gc_xor_en              : SRFF;
  sel_xor_gt_id [14..0]      : SRFF;
  sel_mp_wr_ff               : SRFF;
  sel_start_mp_wr_ff         : SRFF;
  sel_start_mp_rd_ff         : SRFF;


BEGIN

    
  DEFAULTS
    ad_out[]              = GND;
  END DEFAULTS;
   
  ad_out[].clk    = clk;
  sel_ports_d.clk = clk;
  lw_r        = lw_r_i;
  ad[]      = ad_i[];
  IF sel_ports THEN
    ad_o[]  = ad_out[];        -- mode registers read back data to local bus
  ELSE
    ad_o[]  = mem_data[];
  END IF;
  ad_oe         = sel_read_ic;
  bus_end  = wait_l & !ready_i & !den & (!blast # !term) # ads & den;
  sel_gmode.clk         = clk;
  sel_gmode.clrn        = clrn;
  sel_gmode.r           = bus_end;
  ready                 = ready_i;
  bterm                 = VCC;
  sel_ic_lcell          = sel_ic;
  sel_ports             = sel_gmode;
  den.clk               = clk;
  den.s                 = bus_end;
  den.r                 = !ads;
  sel_ic.clk            = clk;
  sel_ic.clrn           = clrn;
  sel_ic.r              = bus_end;
  sel_read_ic.clk       = clk;
  sel_read_ic.clrn      = clrn;
  sel_read_ic.r         = bus_end;
  sel_addr_1v[].clk     = clk;
  sel_addr_1v[].clrn    = clrn;
  sel_addr_1v[].r       = bus_end;
    
  sel_addr_2v[].clk     = clk;
  sel_addr_2v[].clrn    = clrn;
  sel_addr_2v[].r       = bus_end;
    
  sel_addr_3v[].clk     = clk;
  sel_addr_3v[].clrn    = clrn;
  sel_addr_3v[].r       = bus_end;
    
  sel_gc_and_en.clk     = clk;
  sel_gc_and_en.clrn    = clrn;
  sel_gc_and_en.r       = bus_end;
    
  sel_R[].clk           = clk;
  sel_R[].clrn          = clrn;
  sel_R[].r             = bus_end;
    
  sel_and_gt_id[].clk   = clk;
  sel_and_gt_id[].clrn  = clrn;
  sel_and_gt_id[].r     = bus_end;
    
  sel_layer_num.clk     = clk;
  sel_layer_num.clrn    = clrn;
  sel_layer_num.r       = bus_end;
    
  sel_addr_1v_xor[].clk  = clk;
  sel_addr_1v_xor[].clrn  = clrn;
  sel_addr_1v_xor[].r   = bus_end;
    
  sel_addr_2v_xor[].clk  = clk;
  sel_addr_2v_xor[].clrn  = clrn;
  sel_addr_2v_xor[].r   = bus_end;
    
  sel_addr_3v_xor[].clk  = clk;
  sel_addr_3v_xor[].clrn  = clrn;
  sel_addr_3v_xor[].r   = bus_end;
    
  sel_gc_xor_en.clk     = clk;
  sel_gc_xor_en.clrn    = clrn;
  sel_gc_xor_en.r       = bus_end;
    
  sel_xor_gt_id[].clk   = clk;
  sel_xor_gt_id[].clrn  = clrn;
  sel_xor_gt_id[].r     = bus_end;
    
  sel_mp_wr             = sel_mp_wr_ff & wait_l;
  sel_mp_wr_ff.clk      = clk;
  sel_mp_wr_ff.clrn     = clrn;
  sel_mp_wr_ff.r        = bus_end;
    
  sel_start_mp_wr       = sel_start_mp_wr_ff & wait_l;
  sel_start_mp_wr_ff.clk  = clk;
  sel_start_mp_wr_ff.clrn  = clrn;
  sel_start_mp_wr_ff.r  = bus_end;
    
  sel_start_mp_rd       = sel_start_mp_rd_ff & wait_l;
  sel_start_mp_rd_ff.clk  = clk;
  sel_start_mp_rd_ff.clrn  = clrn;
  sel_start_mp_rd_ff.r  = bus_end;
    
  IF !ads THEN
    addr[]                = ad[31..0];
  ELSE
    addr[]                = addr[] + 32;
  END IF;
  addr[].clk            = clk;
  addr[].ena            = !ads  #  wait_l & !ready_i & !den;
  --============================================
  --=  Selectors to all memory address spaces  =
  --============================================
  addr_1v[][31..0]      =  ad[31..0];
  addr_2v[][31..0]      =  ad[31..0];
  addr_3v[][31..0]      =  ad[31..0];
  gc_and_en[14..0]      =  ad[14..0];
  R[][31..0]            =  ad[31..0];
  and_gt_id[][31..0]    =  ad[31..0];
  layer_num[31..0]      =  ad[31..0];
  addr_1v_xor[][31..0]  =  ad[31..0];
  addr_2v_xor[][31..0]  =  ad[31..0];
  addr_3v_xor[][31..0]  =  ad[31..0];
  gc_xor_en[14..0]      =  ad[14..0];
  xor_gt_id[][31..0]    =  ad[31..0];
    
    
  sel_ports_d = sel_ports;
   
  ready_i    = !sel_ic_lcell # !sel_ports_d & sel_read_ic & sel_ports # 
      (
        sel_mp_wr_ff
      # sel_start_mp_wr_ff
      # sel_start_mp_rd_ff
      )  & !mem_ready;

    
   
  



  addr_1v[][31..0].clk  = clk;
  addr_1v[][31..0].clrn  = clrn;
  addr_2v[][31..0].clk  = clk;
  addr_2v[][31..0].clrn  = clrn;
  addr_3v[][31..0].clk  = clk;
  addr_3v[][31..0].clrn  = clrn;
  gc_and_en[14..0].clk  = clk;
  gc_and_en[14..0].clrn  = clrn;
  gc_and_en[14..0].ena  = sel_gc_and_en & lw_r;
  R[][31..0].clk        = clk;
  R[][31..0].clrn       = clrn;
  and_gt_id[][31..0].clk  = clk;
  and_gt_id[][31..0].clrn  = clrn;
  layer_num[31..0].clk  = clk;
  layer_num[31..0].clrn  = clrn;
  layer_num[31..0].ena  = sel_layer_num & lw_r;
  addr_1v_xor[][31..0].clk  = clk;
  addr_1v_xor[][31..0].clrn  = clrn;
  addr_2v_xor[][31..0].clk  = clk;
  addr_2v_xor[][31..0].clrn  = clrn;
  addr_3v_xor[][31..0].clk  = clk;
  addr_3v_xor[][31..0].clrn  = clrn;
  gc_xor_en[14..0].clk  = clk;
  gc_xor_en[14..0].clrn  = clrn;
  gc_xor_en[14..0].ena  = sel_gc_xor_en & lw_r;
  xor_gt_id[][31..0].clk  = clk;
  xor_gt_id[][31..0].clrn  = clrn;
  FOR i IN 0 to  14  GENERATE
    IF sel_addr_1v[i]  THEN
    addr_1v[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  14  GENERATE
    IF sel_addr_2v[i]  THEN
    addr_2v[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  14  GENERATE
    IF sel_addr_3v[i]  THEN
    addr_3v[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  2  GENERATE
    IF sel_R[i]  THEN
    R[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  29  GENERATE
    IF sel_and_gt_id[i]  THEN
    and_gt_id[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  14  GENERATE
    IF sel_addr_1v_xor[i]  THEN
    addr_1v_xor[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  14  GENERATE
    IF sel_addr_2v_xor[i]  THEN
    addr_2v_xor[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  14  GENERATE
    IF sel_addr_3v_xor[i]  THEN
    addr_3v_xor[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  FOR i IN 0 to  14  GENERATE
    IF sel_xor_gt_id[i]  THEN
    xor_gt_id[i][31..0].ena=lw_r;
    END IF;
  END GENERATE;
  IF !ads & !ad[31] THEN
    IF (ad[24..24] == 0) THEN
      IF (ad[23..21] == (id2,id1,id0) ) THEN
        sel_ic.s = VCC;
        sel_read_ic.s = !lw_r;
  
        IF !ad[20] THEN
          sel_gmode.s=VCC;
          FOR i IN 0 to 14 GENERATE
            sel_addr_1v[i].s  =  (ad[10..2] == H"AC"+i);
          END GENERATE;
          FOR i IN 0 to 14 GENERATE
            sel_addr_2v[i].s  =  (ad[10..2] == H"BC"+i);
          END GENERATE;
          FOR i IN 0 to 14 GENERATE
            sel_addr_3v[i].s  =  (ad[10..2] == H"CC"+i);
          END GENERATE;
          sel_gc_and_en.s =  (ad[10..4] == H"5");
          FOR i IN 0 to 2 GENERATE
            sel_R[i].s  =  (ad[10..2] == H"18"+i);
          END GENERATE;
          FOR i IN 0 to 29 GENERATE
            sel_and_gt_id[i].s  =  (ad[10..2] == H"DC"+i);
          END GENERATE;
          sel_layer_num.s =  (ad[10..4] == H"E");
          FOR i IN 0 to 14 GENERATE
            sel_addr_1v_xor[i].s  =  (ad[10..2] == H"FC"+i);
          END GENERATE;
          FOR i IN 0 to 14 GENERATE
            sel_addr_2v_xor[i].s  =  (ad[10..2] == H"10C"+i);
          END GENERATE;
          FOR i IN 0 to 14 GENERATE
            sel_addr_3v_xor[i].s  =  (ad[10..2] == H"11C"+i);
          END GENERATE;
          sel_gc_xor_en.s =  (ad[10..4] == H"4B");
          FOR i IN 0 to 14 GENERATE
            sel_xor_gt_id[i].s  =  (ad[10..2] == H"130"+i);
          END GENERATE;
  
        ELSE
            -- SRAM / internal memories address space
          sel_mp_wr_ff.s = (ad[15..5]  == H"0")&lw_r;
          sel_start_mp_wr_ff.s = (ad[15..4]  == H"2")&lw_r;
          sel_start_mp_rd_ff.s = (ad[15..4]  == H"6")&lw_r;
        END IF;

      END IF;
    END IF;
  END IF;
  END;
